题目：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/
# 版本一 
第一下想到的是错误的逻辑
```
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
    myS = new Set(s)
    let array = Array.from(myS)
    return array.length
};
```
例如："pwwkew"正确的输出应该为3，这里只做了简单的去重，输出结果为4.
## 思考
这个让我思考到串的模式匹配算法，KMP和BF，比模式匹配简单些。BF可以应用在这里，但是明显会很复杂，不确定会不会超过时间限制。

# 版本二 暴力匹配BF
```
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function (s) {
    let sub = []
    let max = 0
    for (let i = 0; i < s.length; i++) {
        sub = []
        let test = s.substring(i, s.length)
        for (item of test) {
            if (!sub.includes(item)) {
                sub.push(item)
            } else {
                break
            }
        }
        if (sub.length > max) {
            max = sub.length
        }
    }

    return max
};
```
## 思考
看[官解](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/)提到了一种滑动窗口的概念,感觉就是简单版的kmp，因为第一遍扫描的时候，扫到第i个位置发现重复元素，从第2个到第i-1个位置是没有重复元素的，不需要再重复扫描，可以直接从第i和个位置开始扫描。
